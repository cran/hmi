<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="date" content="2017-04-26" />

<title>hmi: hierarchical multiple imputation</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">hmi: hierarchical multiple imputation</h1>
<h4 class="author"><em>Matthias Speidel</em></h4>
<h4 class="author"><em>Jörg Drechsler</em></h4>
<h4 class="author"><em>Shahab Jolani</em></h4>
<h4 class="date"><em>2017-04-26</em></h4>



<div id="purpose-of-package" class="section level2">
<h2>Purpose of package</h2>
<p>The hmi package allows the user to run single level and multilevel imputation models. The big additional benefit of this package is the user-friendliness. It is designed for researchers, experienced in running single und multilevel analysis models, but not in writing own multilevel imputation routines.</p>
<p>The user just has to pass the data to the main function and, optionally, his analysis model. Basically the package then translates this analysis model into commands to impute the data according to it with functions from <code>mice</code>, <code>MCMCglmm</code> or routines build for this package.</p>
</div>
<div id="basic-functionality" class="section level2">
<h2>Basic functionality</h2>
<p>The main function that wraps up all sub functions is <code>hmi</code>.</p>
<p>In the most simple case, the user just passes his <code>data</code> to <code>hmi</code>. In this case all variables with missing values are imputed based on a single level imputation model including the other variables. The situation, for which the package was built for, is that the user additionally passes his analysis model as <code>model_formula</code> to <code>hmi</code> (and defines more details if he wants to). The function then analyzes the <code>model_formula</code>, checks whether it suits to the data given and runs some other checks on the data given (size of the data, number of remaining observations etc.).</p>
<div id="sequential-regression-imputation" class="section level3">
<h3>Sequential regression imputation</h3>
<p>Principally there are two strategies to impute missing data. One is the <em>joint modeling</em> approach. It assumes a joint distribution of the variables and draws values based on this distribution. For this package we see this approach not to be suitable and therefore choose the <em>sequential regression</em> approach. It imputes variables step by step until convergence.</p>
<p>As a starting point, all variables with missing values are imputed by samples of observed values in this variable. After this is done, <code>hmi</code> starts with the actual, adequate imputation: the first variable with missing values is selected and imputed based on the other variables with an imputation model congenial to the <code>model_formula</code>. Dependent on the situation this can either be a single level or a multilevel model. As different classes of variables require different classes of imputation routines, <code>hmi</code> also determines which type the variable is of (continuous, binary etc. all supported types are listed below).</p>
<p>Then the next incomplete variable is imputed based on this firstly imputed variable and the other (yet only sample-imputed) variables. Then the third, fourth, … incomplete variable is imputed. The process of imputing all incomplete variables once is called a <em>cycle</em>. Now, a next cycle can begin, imputing the first variable again, but this time based on the other variables which now (once) have been imputed adequately. After <code>maxit</code> cycles, the current state of the variables is stored, building one imputation. Then the process starts again, until <code>M</code> imputed data sets are present.</p>
</div>
<div id="output-of-hmi" class="section level3">
<h3>Output of <code>hmi</code></h3>
<p>The package is build to be compatible with <code>mice</code>; especially with regard the output. <code>hmi</code> returns, like <code>mice</code>, a so-called <code>mids</code>-object (multiply imputed data set).</p>
<p>This allows the user, familiar with <code>mice</code> to use functions designed for <code>mice</code>-outputs without switching barriers. For example, running the generic <code>plot()</code>-function on a <code>mids</code>-object calls the function <code>plot.mids</code> showing the means and variances of the imputed variables over the different imputations, regardless whether the <code>mids</code>-object came from <code>mice</code> or <code>hmi</code>. Or he could call the <code>complete</code>-function delivered by <code>mice</code> to get a completed data set where the NAs are replaced by the imputed values.</p>
</div>
</div>
<div id="the-different-types-of-imputation-routines-the-supported-types-of-variables" class="section level2">
<h2>The different types of imputation routines / the supported types of variables</h2>
<p>Different variable types require different imputation routines. For example for binary variables it would be unpleasant to impute other values than <code>0</code> and <code>1</code>. And factor variables with levels <code>&quot;A&quot;</code>, <code>&quot;B&quot;</code> and <code>&quot;C&quot;</code> need an imputation routine different to the ones for binary and continuous variables.</p>
<p>To determine which imputation routine shall be used, we first have to decide whether a single level or multilevel model shall be used. This decision is mainly based on the <code>model_formula</code> given by the user. The formula is decomposed into its fixed effects, random effects and cluster variable parts (if present). If the cluster variable and the random effect variables are actually present in the data set and available in the moment of imputation, a multilevel model is run. In all other cases (i.e. not available or not specified) a single level model is run.</p>
<p>The second question is which type the variable is of. We distinguish eight different types of variable. The next sections describe how we assign a type to a variable and how the imputation model works for these types. For some special cases the rules of assignment might give unwanted results. Therefore the user can specify the types of the variables in advance by setting up a <code>list_of_types</code>. Section <em>Pre-definition of the variable types</em> explains how this is done.</p>
<p><code>MCMCglmm</code> assumes for each type of variable, that there is a latent variable <span class="math inline">\(l\)</span> present which can be expressed by fix and random effects. So <span class="math inline">\(l = X \cdot \beta + Z \cdot u + \varepsilon\)</span> <span class="citation">(cf. Hadfield 2010 eq. 3)</span>. The probability of observing <span class="math inline">\(y_i\)</span> is conditioned on <span class="math inline">\(l_i\)</span>: <span class="math inline">\(f_i(y_i|l_i)\)</span>, with <span class="math inline">\(f_i\)</span> being the probability density function (pdf) for <span class="math inline">\(y_i\)</span>. More about the theory behind <code>MCMCglmm</code> can be found in the below.</p>
<p>For completeness: each imputation routine starts with some cleanup. This includes for example removing linear dependent variables (or other variables likely to hamper the imputation model like factors with more then 10 levels) from the current imputation.</p>
<div id="binary-variables-keyword-binary" class="section level3">
<h3>Binary variables (keyword <code>&quot;binary&quot;</code>)</h3>
<p>Data are considered to be binary if there are only two unique values. This includes for example <code>0</code> and <code>1</code> or <code>&quot;m&quot;</code> and <code>&quot;f&quot;</code>.</p>
<p>The single level imputation model is a logistic regression for a binomial family with a logit link. Based on this model new (Bayesian) imputation parameters are drawn. Those parameters are then used to sample binary observations, given the other covariates. This is implemented in the <code>mice.impute.logreg</code>-function which is called when running <code>mice</code> with the <code>method = &quot;logreg&quot;</code>.</p>
<p>In the multilevel model <code>MCMCglmm</code> is called with <code>family = categorical</code>. This uses the pdf <span class="math inline">\(\exp(l)/(1+\exp(l))\)</span></p>
<p>Settings where our rule of classification might fail are small data, or data with very few observed individuals or if a third possible category is unobserved. E.g. in a small health survey it could happen that none of the respondents reported having had two (or more) Bypass operations. So here a count variable would falsely be classified as binary.</p>
</div>
<div id="continuous-variables-keyword-cont" class="section level3">
<h3>continuous variables (keyword <code>&quot;cont&quot;</code>)</h3>
<p>Any numeric vector, that isn’t one of the other types, is considered to be continuous.</p>
<p>In the single level model, <code>mice.impute.norm</code> from <code>mice</code> is called. This routine first draws imputation parameters (regression coefficients and residual variance) and then draws imputation values with these parameters.</p>
<p>In the multilevel model <code>MCMCglmm</code> is called with <code>family = categorical</code>. This uses the normal distribution.</p>
</div>
<div id="semicontinuous-variables-keyword-semicont" class="section level3">
<h3>semicontinuous variables (keyword <code>&quot;semicont&quot;</code>)</h3>
<p>A continuous variable with more than 5% values being 0, is defined being “semicontinuous”.</p>
<p>The first step of imputing semicontinuous variables is to temporarily change internally all non-zero values to 1. Then via a binary imputation (based on the temporarily 0/1 variable) it is decided for the missing values whether they shall be 0 or non-zero.</p>
<p>In a third step, for those being chosen to be non-zero, we run a continuous imputation model based on the originally non-zero observations. (Missing values, chosen to be 0, don’t need further treatment, their imputation values is just 0).</p>
</div>
<div id="rounded-continuous-variables-keyword-roundedcont" class="section level3">
<h3>rounded continuous variables (keyword <code>&quot;roundedcont&quot;</code>)</h3>
<p>If more than 50% of the data are divisible by 5, they are considered to be “rounded continous”. For example the income in surveys is often reported rounded by the respondents.</p>
<p>For this type of variable, we use our own imputation routine.</p>
<p>It estimates a model for the rounding degree G and for the variable Y itself, then parameters for the joint distribution of G and Y are drawn and afterward used to impute values. Not only missing values get a new imputed value, but also values with an interval response (e.g. “between 1500 and 2000”) and (presumably) rounded responses.</p>
<p>Individuals with NAs get imputed values drawn from the normal distribution with the estimated parameters from the joint distribution. Interval responses get imputed values drawn from the truncated normal distribution. For individuals with (presumably) rounded responses, values are drawn for G and Y and then checked whether this combination could explain the actual observed value of Y for this observation. E.g. if 2950 is observed then the combination (G = degree 100, Y = 3000) would not fit to the observed response. In the case of a mismatch, the process is repeated until G and Y match.</p>
<p>The process is described in detail in <span class="citation">(Drechsler, Kiesl, and Speidel 2015)</span>.</p>
</div>
<div id="interval-variables-keyword-interval" class="section level3">
<h3>interval variables (keyword <code>&quot;interval&quot;</code>)</h3>
<p>We see interval data as a special case of imprecise observations given as a mathematical interval <span class="math inline">\([l;~u]\)</span> with <span class="math inline">\(l \leq u\)</span>. For example a person could refuse to report its precise income <span class="math inline">\(y\)</span>, but is willing to report that it is something between 1500 and 2000. In this case the interval <span class="math inline">\([1500; ~2000]\)</span> is the observed value for this individual. Precise answers like <span class="math inline">\(3217\)</span> can be seen as special cases of interval data where <span class="math inline">\(l=u\)</span>, here <span class="math inline">\([3217;~3217]\)</span>. Missing values can be seen as the extreme case <span class="math inline">\([-\infty;~\infty]\)</span>.</p>
<p>To our knowledge, there is no standard in R for interval data. One possibility would be to generate <em>two</em> variables for the lower and the upper bounds of the data. Based on this approach <span class="citation">(Wiencierz 2012)</span> set up the <code>idf</code>-objects (interval data frame) in her package <code>linLIR</code>. We didn’t follow this approach for our package because it would need an inconvenient workflow to link both variables appropriately. Instead, we define a new class <code>interval</code> for interval variables. Interval variables actually come in <em>one</em> variable. Technically one observation in such an interval variable is <code>&quot;l;u&quot;</code> with <code>l</code> (resp. <code>u</code>) being a scalar with optional decimal places in American notation (with a full stop. E.g. <code>&quot;1234.56;3000&quot;</code>) or <code>-Inf</code> (resp. <code>Inf</code>).</p>
<p>Within most <code>R</code> functions such an <code>interval</code>-variable will be treated as a factor. But it is a factor with maybe more than 100 categories. So we suggest not to use such a variable as covariate in a imputation model. Within <code>hmi</code> it would not be used as this would be too many categories. The main reason to use an <code>interval</code> variable is to impute this variable according to <span class="citation">(Drechsler, Kiesl, and Speidel 2015)</span>.</p>
<p>We also implemented functions to run basic calculations on interval data (<code>+</code>, <code>-</code>, ’*’ and <code>/</code>), to generate interval data based on two vectors (<code>as_interval</code>) or to split interval data up into their lower and upper bounds (<code>split_interval</code>).</p>
<p>Furthermore, we want to encourage people working with interval data or variables and hope that a standard for this will emerge. For this reason we think, users should be able to switch easily between <code>idf</code> and <code>interval</code> objects as one might be better for one task and the other for a different task. So we implemented <code>idf2interval</code> and <code>interval2idf</code> which conveys an object from one format to the other (as far as possible).</p>
</div>
<div id="count-variables-keyword-count" class="section level3">
<h3>count variables (keyword <code>&quot;count&quot;</code>)</h3>
<p>Every vector with integers (which is not semicontinuous) is considered to be count data. By this definition, every continuous variable, rounded to the next integer is considered to be a count variable.</p>
<p>For both, single level and multilevel settings, we use <code>MCMCglmm</code> with the poisson distribution for the latent variable.</p>
</div>
<div id="categorical-variables-keyword-categorical" class="section level3">
<h3>categorical variables (keyword <code>&quot;categorical&quot;</code>)</h3>
<p>Factor-variables (or variables with more than two categories - if they are not one of the previous types) are considered to be categorical variables.</p>
<p>For the single level setting we use the <code>cart</code> approach in <code>mice</code>. This runs a regression tree for the observed data and then samples from suitable leaves for the individuals with missing values.</p>
<p>In the multi level setting, we use the <code>categorical</code> setting in <code>MCMCglmm</code> with runs a multilevel regression model for each category (based on the observed individuals). For the individuals with missing values, probabilities for each category are be calculated and than a category sampled based on these probabilities.</p>
</div>
<div id="ordered-categorical-variables-keyword-ordered_categorical" class="section level3">
<h3>ordered categorical variables (keyword <code>&quot;ordered_categorical&quot;</code>)</h3>
<p>In the special case, that a factor variable is ordered, we treat it as <em>ordered categorical</em>.</p>
<p>For the single level case <code>mice</code> is told to run an ordered logistic model. <code>MCMCglmm</code> for the multilevel setting runs the <code>ordinal</code> model.</p>
<p>The assumption behind both models is that a latent variable <span class="math inline">\(l\)</span> is assumed to be present and dependent on how many thresholds <span class="math inline">\(\gamma\)</span>, the variable exceeded, a higher category <span class="math inline">\(k\)</span> is observed.</p>
</div>
<div id="intercept-variable-keyword-intercept" class="section level3">
<h3>Intercept variable (keyword <code>&quot;intercept&quot;</code>)</h3>
<p>A constant variable (only one kind of observation) is considered to be a intercept variable. If you run an analysis model with an intercept variable (even if it is only implicit like in <code>y ~ x1 + x2</code>), your data set needs to have such an intercept variable. <code>hmi</code> is quite strict here and different to what you might expect.</p>
</div>
</div>
<div id="pre-definition-of-the-variable-types" class="section level2">
<h2>pre-definition of the variable types</h2>
<p>If you want to have manual control over the process which method is used for each variable, you can specify a <code>list_of_types</code>. This is a <code>list</code> where each list element has the name of a variable in the data frame. The elements have to contain a single character string denoting the type of the variable (the keywords from the previous section). With the function <code>list_of_types_maker</code>, the user can get the framework for this object.</p>
<p>In most scenarios this is shouldn’t be necessary. One example where it might be necessary is when only two observations of a continuous variable are left - because in this case <code>get_type</code> interpret this variable to be binary. Or if you want to impute rounded continuous variables not as <code>&quot;count&quot;</code>, but as <code>&quot;cont&quot;</code>.</p>
<p>The example uses the data set <code>CO2</code> about the “Carbon Dioxide Uptake in Grass Plants”, which comes along with <code>R</code>. If you run the common <code>str(CO2)</code>, you get the information that the variable <code>Plant</code> is an <code>Ord.factor w/ 12 levels</code>, <code>Type</code> is a <code>Factor w/ 2 levels</code>, <code>Treatment</code> is a <code>Factor w/ 2 levels</code>, <code>conc</code> is a <code>num</code> and so is <code>uptake</code>.</p>
<p><code>hmi</code> draws similar conclusions. A difference would be that we call Factors with 2 levels “binary”. Also the variable <code>conc</code> would be considered to be a special case of a continuous variable - a rounded continuous because every value of the ambient carbon dioxide concentration is divisible by at least 5.</p>
<p>You can see in advance how variables will be treated internally by <code>hmi</code> if you call the <code>list_of_types_maker</code>. For example <code>example_list_of_types &lt;- list_of_types_maker(CO2)</code> gives you the following list: <!--
source('C:/Users/Matthias/Documents/hmi/R/hmi_smallfunctions_2017-04-20.R')
example_list_of_types <- list_of_types_maker(CO2)
example_list_of_types
--></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## $Plant
## [1] &quot;ordered_categorical&quot;
## 
## $Type
## [1] &quot;binary&quot;
## 
## $Treatment
## [1] &quot;binary&quot;
## 
## $conc
## [1] &quot;roundedcont&quot;
## 
## $uptake
## [1] &quot;cont&quot;</code></pre></div>
<p>Now you can modify <code>example_list_of_types</code> according to your preferences. For example if you want the variable <code>conc</code> to be continuous, you can write <code>example_list_of_types[[&quot;conc&quot;]] &lt;- &quot;cont&quot;</code>. If you finished your modification on <code>example_list_of_types</code>, pass this list to <code>hmi</code> via its parameter <code>list_of_types</code>. In our example it would be <code>hmi(data = CO2, list_of_types = example_list_of_types)</code>. (Note, that <code>CO2</code> doesn’t contain any missing value, so there is no need for imputation.)</p>
</div>
<div id="the-theory-behind-mcmcglmm" class="section level2">
<h2>the theory behind <code>MCMCglmm</code></h2>
<p>The <code>MCMCglmm</code> package is described in detail in <span class="citation">(Hadfield 2010)</span>.</p>
<p>He assumes for every observed <em>y</em> that a latent variable <em>l</em> is present. Based on this assumption each model consists of three parts.</p>
<ol style="list-style-type: decimal">
<li>a link function.</li>
<li>a linear mixed model (with fixed and random effects) for <em>l</em>. It has to form <span class="math inline">\(l = X\beta + Z u + \varepsilon\)</span>, with <code>X</code> being the fixed effects variables, <code>Z</code> than random effects variables. <span class="math inline">\(\beta\)</span> and <span class="math inline">\(u\)</span> are the fix and random regression parameters; <span class="math inline">\(\varepsilon\)</span> is the residual.</li>
<li>a block diagonal covariance matrix including block matrices. Firstly <span class="math inline">\(B\)</span> for the prior covariances of the fixed effects <span class="math inline">\(\beta\)</span>, secondly the random effects covariance matrix <span class="math inline">\(G\)</span> and thirdly the residual variance (matrix) <span class="math inline">\(R\)</span>.</li>
</ol>
<p>The link function is defined by the type of variable that shall be imputed. Which variables define <span class="math inline">\(X\)</span> and <span class="math inline">\(Z\)</span> is automatically determined by <code>hmi</code> via the <code>model_formula</code> given by the user.</p>
<p>The most explanations probably need the covariance matrices. Hadfield predefines the priors to be inverse-wishart distributed. The choice left to the user, is to specifiy the parameters of the inverse-wishart distribution. It is allowed to specify parameters leading to improper priors.</p>
<p>The product of likelihood and prior distribution gives the posterior distribution for the imputation parameters. <code>MCMCglmm</code> samples imputation parameters from the posterior and <code>hmi</code> draws imputation values based on these imputation parameters. This is done by <em>Markov Chain Monte Carlo</em> (MCMC) methods like <em>Metropolis-Hasting</em>, <em>Gibbs Sampling</em> and <em>Sclice Sampling</em> (see Hadfield’S <a href="https://CRAN.R-project.org/package=MCMCglmm/vignettes/CourseNotes.pdf">MCMCglmm Course Notes</a> for more details).</p>
<div id="b" class="section level3">
<h3><span class="math inline">\(B\)</span></h3>
<p>We specify the inverse-wishart distribution to have an identity scale matrix and degrees of freedom of <code>nu = 0.002</code>. This leads to improper but useful priors.</p>
</div>
<div id="g" class="section level3">
<h3><span class="math inline">\(G\)</span></h3>
<p>Regarding the random effects <code>MCMCglmm</code> allows different specifications for the structure of the random effects covariance matrix <span class="citation">(Hadfield 2010, tab. 2)</span>. We use <code>us()</code> to allow different correlation between the random effects. The second random effects issue to be specified for a <code>MCMCglmm</code> model is the prior for the covariance matrix. A convincing choice found in the <code>MCMCglmm</code> course notes is to define a <span class="math inline">\(q \times q\)</span> identity matrix with <span class="math inline">\(q\)</span> being the number of random effect variables and to set <code>nu = 0.002</code> which results in an inverse-gamma prior with scale and shape equal to 0.001.</p>
</div>
<div id="r" class="section level3">
<h3><span class="math inline">\(R\)</span></h3>
<p>For the residuals in most cases, we use non-informative, but improper priors by setting <code>V = 1e-07</code> and <code>nu = -2</code>. In some cases, like logistic models, we have to fix the residual variance at <code>1</code>.</p>
</div>
</div>
<div id="how-to-use-it" class="section level2">
<h2>how to use it</h2>
<div id="single-level-example" class="section level3">
<h3>single level example</h3>
<p>To illustrate the use of <code>hmi</code>, we stick to the <code>CO2</code> data set; but as it has no missing values, we add those artificially:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ex &lt;-<span class="st"> </span>CO2
<span class="kw">set.seed</span>(<span class="dv">1</span>)
ex[<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(CO2), <span class="dt">size =</span> <span class="dv">20</span>), <span class="st">&quot;uptake&quot;</span>] &lt;-<span class="st"> </span><span class="ot">NA</span>
<span class="kw">head</span>(ex) <span class="co"># e.g. in line 5 there is a NA now.</span></code></pre></div>
<pre><code>##   Plant   Type  Treatment conc uptake
## 1   Qn1 Quebec nonchilled   95   16.0
## 2   Qn1 Quebec nonchilled  175   30.4
## 3   Qn1 Quebec nonchilled  250   34.8
## 4   Qn1 Quebec nonchilled  350   37.2
## 5   Qn1 Quebec nonchilled  500     NA
## 6   Qn1 Quebec nonchilled  675   39.2</code></pre>
<p>The most simple call of <code>hmi</code> would be be:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;hmi&quot;</span>)
result &lt;-<span class="st"> </span><span class="kw">hmi</span>(ex)</code></pre></div>
<p><code>result</code> is a <code>mids</code> (<em>multiple imputed data set</em>) object as it also is returned by <code>mice</code>. So the functionality of mice can be used. For example the arithmetic mean and standard deviation of the imputation values across the <code>M</code> imputations can be plotted. Here we have 10 different lines for each of the 10 imputations (in <code>hmi</code> the default value is <code>M = 10</code>). And each line consists of 5 points for each of the 5 iterations (in <code>hmi</code> the default value is <code>maxit = 5</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;hmi&quot;</span>)
<span class="kw">set.seed</span>(<span class="dv">1</span>)
result &lt;-<span class="st"> </span><span class="kw">hmi</span>(ex)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(result, <span class="dt">layout =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">1</span>))</code></pre></div>
<!-- The plots show no extreme results to cause worries. -->
<p>Another useful tool from <code>mice</code> is the <code>complete</code> function. It gives you a data set with the original and imputed values. Here we show the first rows of the completed data set:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(<span class="kw">complete</span>(result, <span class="dv">1</span>))</code></pre></div>
<pre><code>## Grouped Data: uptake ~ conc | Plant
##   Plant   Type  Treatment conc  uptake
## 1   Qn1 Quebec nonchilled   95 16.0000
## 2   Qn1 Quebec nonchilled  175 30.4000
## 3   Qn1 Quebec nonchilled  250 34.8000
## 4   Qn1 Quebec nonchilled  350 37.2000
## 5   Qn1 Quebec nonchilled  500 20.1881
## 6   Qn1 Quebec nonchilled  675 39.2000</code></pre>
</div>
<div id="multilevel-example" class="section level3">
<h3>multilevel example</h3>
<p>Let’s move to a more elaborated imputation than just calling <code>hmi(example)</code>. A big part of the packages contribution is the multilevel imputation. For example, if your interest lies in modeling the effect of the carbon dioxide uptake rates (target variable <code>uptake</code>) by the ambient carbon dioxide concentration (explanatory variable <code>conc</code>) - and an intercept. Assuming that the effects of <code>conc</code> and the intercept on <code>uptake</code> can differ across the different plants (random effect variable <code>Plant</code>), your analysis model using <code>lmer</code> from the <code>lme4</code> package would be <code>lmer(uptake ~ 1 + conc + (1 + conc | Plant), data = example)</code>. Just for clarification how this model is read by <code>hmi</code>: the word left to <code>~</code> denotes the target variable, the parts right to <code>~</code> denote the fixed and random effects variables and the cluster ID. And in more detail, the parts within the parentheses left to <code>|</code> denote the random effects variables and the word right to <code>|</code> denotes the cluster ID.</p>
<p>If you run this model, you will get results but also a warning about convergence:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;lme4&quot;</span>)
<span class="kw">lmer</span>(uptake <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">|</span><span class="st"> </span>Plant), <span class="dt">data =</span> ex)</code></pre></div>
<pre><code>## Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = control
## $checkConv, : Model failed to converge with max|grad| = 0.00680642 (tol =
## 0.002, component 1)</code></pre>
<pre><code>## Warning in checkConv(attr(opt, &quot;derivs&quot;), opt$par, ctrl = control$checkConv, : Model is nearly unidentifiable: very large eigenvalue
##  - Rescale variables?</code></pre>
<pre><code>## Linear mixed model fit by REML ['lmerMod']
## Formula: uptake ~ 1 + conc + (1 + conc | Plant)
##    Data: ex
## REML criterion at convergence: 445.469
## Random effects:
##  Groups   Name        Std.Dev. Corr
##  Plant    (Intercept) 3.795076     
##           conc        0.007931 1.00
##  Residual             6.219132     
## Number of obs: 64, groups:  Plant, 12
## Fixed Effects:
## (Intercept)         conc  
##    19.14681      0.01834  
## convergence code 0; 2 optimizer warnings; 0 lme4 warnings</code></pre>
<p>As <code>lmer</code> suggests to rescale variables, we will rescale <code>conc</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;lme4&quot;</span>)
ex_<span class="dv">2</span> &lt;-<span class="st"> </span>ex
ex_<span class="dv">2</span><span class="op">$</span>conc &lt;-<span class="st"> </span>(ex_<span class="dv">2</span><span class="op">$</span>conc <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(ex_<span class="dv">2</span><span class="op">$</span>conc))<span class="op">/</span><span class="kw">sd</span>(ex_<span class="dv">2</span><span class="op">$</span>conc)
mod &lt;-<span class="st"> </span><span class="kw">lmer</span>(uptake <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">|</span><span class="st"> </span>Plant), <span class="dt">data =</span> ex_<span class="dv">2</span>)</code></pre></div>
<p>The coefficients can be interpreted as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fixef</span>(mod)</code></pre></div>
<pre><code>## (Intercept)        conc 
##   27.122837    5.425974</code></pre>
<p>The <code>uptake</code> of carbon dioxide at zero ambient carbon dioxide concentration is <code>27.12</code> units (micromole/m^2 sec). If now the ambient carbon dioxide concentration increases by one standard deviation, the expected <code>uptake</code> increases by <code>5.43</code> units.</p>
<p>The estimated random effects covariance matrix can be obtained by</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vcov</span>(mod)</code></pre></div>
<pre><code>## 2 x 2 Matrix of class &quot;dpoMatrix&quot;
##             (Intercept)     conc
## (Intercept)    5.023051 1.500895
## conc           1.500895 1.184934</code></pre>
<p>It shows moderate variances and positively correlated (<span class="math inline">\(\rho = 0.615\)</span>) random effects. So plants with a higher “baseline uptake” have (on average) also a higher concetration effect.</p>
<p>If we would run again <code>hmi(example_2)</code> without further specification, we would end up in running a single level imputation. To make <code>hmi</code> run a multilevel imputation model, you have to specify a multilevel analysis model and this has two mandatory elements: 1. variables with a clusterspecific effect (<em>random effects variables</em>) and 2. a variable indicating the clusters. By passing your analysis model formula to <code>hmi</code> you implicitly specify your imputation model(s). If there are more variables with missing values, then the other variables are tried to be imputed with a similar model. This means that maybe only one covariate in the analysis model becomes the target variable in the imputation model, but the random effects variables and the cluster ID keep the same (except in the case a random effects variable is to be imputed. In this case this variable is dropped from the random effects part of the imputation model). So here a multilevel imputation would be set up by (as we have only one variable to impute, we can set maxit to 1):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
result_multi &lt;-<span class="st"> </span><span class="kw">hmi</span>(<span class="dt">data =</span> ex_<span class="dv">2</span>, <span class="dt">model_formula =</span> uptake <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">|</span><span class="st"> </span>Plant), <span class="dt">maxit =</span> <span class="dv">1</span>)</code></pre></div>
<p>Here we get the message that “Intercept” was not found in the data and we can decide whether we want to stop the imputation routine or continue with a single level imputation. The reason for this message is the strict control in <code>hmi</code> whether your model and your data fit together. So if you are sure that you want to have a intercept variable in your model, include one into your data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ex_<span class="dv">2</span><span class="op">$</span>Intercept &lt;-<span class="st"> </span><span class="dv">1</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
result_multi &lt;-<span class="st"> </span><span class="kw">hmi</span>(<span class="dt">data =</span> ex_<span class="dv">2</span>, <span class="dt">model_formula =</span> uptake <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">|</span>Plant), <span class="dt">maxit =</span> <span class="dv">1</span>)</code></pre></div>
<p>Now the imputation is complete and with the resulting <code>mids</code>-object you could do all the things described in the section above.</p>
<p>Here we were especially interested in multilevel models, so we want to run our analysis model on the imputed data. By this it is meant that the model is run on every of the <code>M</code> completed data set and then the results are combined according to Rubin’s combining rules <span class="citation">(Rubin 1987)</span>.</p>
<p><code>mice</code> has the functions <code>fit</code> and <code>pool</code> to do this. But only certain parameters of your model are pooled.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">pool</span>(<span class="kw">with</span>(<span class="dt">data =</span> result_multi, <span class="dt">expr =</span> <span class="kw">lmer</span>(uptake <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">|</span>Plant))))</code></pre></div>
<pre><code>## Call: pool(object = with(data = result_multi, expr = lmer(uptake ~ 
##     1 + conc + (1 + conc | Plant))))
## 
## Pooled coefficients:
## (Intercept)        conc 
##   26.542885    4.890094 
## 
## Fraction of information about the coefficients missing due to nonresponse: 
## (Intercept)        conc 
##   0.1357577   0.1483588</code></pre>
<p><code>hmi_pools</code> tries to give a flexible alternative to this function. The function needs two things</p>
<ol style="list-style-type: decimal">
<li>your multiple imputed data sets (the <code>mids</code> object you created with <code>hmi</code>)</li>
<li>function that you have to define in advance. This has to be a function where you write what you want to do with a completed data set (in most cases this would be <em>run a specific model</em>, but it could be <em>take the mean of the third column</em>) and save all parameters you are interested in, in a list returned by the function.</li>
</ol>
<p>In the following example runs a mixed model and extracts the fixed effects and the random effects covariance matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"> my_analysis &lt;-<span class="st"> </span><span class="cf">function</span>(complete_data){
  <span class="co"># In this list, you can write all the parameters you are interested in.</span>
  <span class="co"># Those will be averaged.</span>
  <span class="co"># So make sure that averaging makes sense and that you only put in single numeric values.</span>
  parameters_of_interest &lt;-<span class="st"> </span><span class="kw">list</span>()

  <span class="co"># ---- write in the following lines, what you are interested in to do with your complete_data</span>
  <span class="co"># the following lines are an example where the analyst is interested in the fixed intercept</span>
  <span class="co"># and fixed slope and the random intercepts variance,</span>
  <span class="co"># the random slopes variance and their covariance</span>
  my_model &lt;-<span class="st"> </span><span class="kw">lmer</span>(uptake <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">+</span><span class="st"> </span>(<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>conc <span class="op">|</span>Plant), <span class="dt">data =</span> complete_data)

  parameters_of_interest[[<span class="dv">1</span>]] &lt;-<span class="st"> </span><span class="kw">fixef</span>(my_model)[<span class="dv">1</span>]
  parameters_of_interest[[<span class="dv">2</span>]] &lt;-<span class="st"> </span><span class="kw">fixef</span>(my_model)[<span class="dv">2</span>]
  parameters_of_interest[[<span class="dv">3</span>]] &lt;-<span class="st"> </span><span class="kw">VarCorr</span>(my_model)[[<span class="dv">1</span>]][<span class="dv">1</span>, <span class="dv">1</span>]
  parameters_of_interest[[<span class="dv">4</span>]] &lt;-<span class="st"> </span><span class="kw">VarCorr</span>(my_model)[[<span class="dv">1</span>]][<span class="dv">1</span>, <span class="dv">2</span>]
  parameters_of_interest[[<span class="dv">5</span>]] &lt;-<span class="st"> </span><span class="kw">VarCorr</span>(my_model)[[<span class="dv">1</span>]][<span class="dv">2</span>, <span class="dv">2</span>]
  <span class="kw">names</span>(parameters_of_interest) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;beta_0&quot;</span>, <span class="st">&quot;beta_1&quot;</span>, <span class="st">&quot;sigma0&quot;</span>, <span class="st">&quot;sigma01&quot;</span>, <span class="st">&quot;sigma1&quot;</span>)

  <span class="co"># ---- do not change this function below this line.</span>
  <span class="kw">return</span>(parameters_of_interest)
 }

<span class="kw">hmi_pool</span>(<span class="dt">mids =</span> result_multi, <span class="dt">analysis_function =</span> my_analysis)</code></pre></div>
<pre><code>##    beta_0    beta_1    sigma0   sigma01    sigma1 
## 26.542885  4.890094 49.504131 19.311003  7.934697</code></pre>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references">
<div id="ref-Drechsler2015">
<p>Drechsler, Jörg, Hans Kiesl, and Matthias Speidel. 2015. “MI Double Feature: Multiple Imputation to Address Nonresponse and Rounding Errors in Income Questions.” <em>Austrian Journal of Statistics</em> 44 (2). doi:<a href="https://doi.org/10.17713/ajs.v44i2.77">10.17713/ajs.v44i2.77</a>.</p>
</div>
<div id="ref-Hadfield2010">
<p>Hadfield, Jarrod D. 2010. “MCMC Methods for Multi-Response Generalized Linear Mixed Models: The MCMCglmm R Package.” <em>Journal of Statistical Software</em> 44 (2). doi:<a href="https://doi.org/10.18637/jss.v033.i02">10.18637/jss.v033.i02</a>.</p>
</div>
<div id="ref-Rubin1987">
<p>Rubin, Donald. 1987. <em>Multiple Imputation for Nonresponse in Surveys</em>. John Wiley &amp; Sons, Inc. doi:<a href="https://doi.org/10.1002/9780470316696">10.1002/9780470316696</a>.</p>
</div>
<div id="ref-Wiencierz2012">
<p>Wiencierz, Andrea. 2012. “linLIR: Linear Likelihood-Based Imprecise Regression.” CRAN. <a href="https://cran.r-project.org/package=linLIR" class="uri">https://cran.r-project.org/package=linLIR</a>.</p>
</div>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
